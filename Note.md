# C语言

---

### 关键字

#### volatile 易变的

主要是防止编译器对变量进行优化

```c
int a,b;    //为a b申请内存
a = 1;      // 1-> CUP  CPU -> 内存(&a)
b = a;      //内存(&a)->CPU CPU->内存(&b)
c = b;      //优化则不需要重新内存a到CPU，直接将CPU中的a传递给c
            //加上修饰后则重新去内存取值
```

哪些情况使用volatile

- 并行设备的硬件寄存器

- 中断服务程序中修改的供其他程序检测的变量

- 多线程中被几个任务共享的变量

#### unsigned 无符号数据类型

```c
void foo(void){
    unsigned int a = 6;
    int b = -20;
    (a+b>6)? puts(">6"):puts("<=6")
}
```

这无符号整型问题的答案是输出是 “>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都**自动转换为无符号类型**。因此-20变成了一个**非常大的正整数**，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。

#### Const 常量修饰符

阻止一个变量被修改

#### typedef 和 define 的区别

**1.原理不同**

 #**define是预处理指令**，在**预处理**时进行简单而机械的**字符串替换**，不做正确性检査。 例如， # define Pl 3.1415926 ，当程序执行 area=PI * r 语句时，PI会被替换为3.1415926。于是该 语句被替换为 area=3.1415926*r 。如果把# define语句中的数字9写成了g，预处理也照样代入，而不去检查其是否合理、合法。 **typedef是关键字**，它在**编译**时处理，所以 typedef具有**类型检查**的功能。它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符 typedef。例如，typedef int INTEGER ，这以后就可用 INTEGER来代替int作整型变量的类型说明了，例如：INTEGER a,b; 用 typedef定义数组、指针、结构等类型将带来很大的方便，不仅使程序书写简单而且使意义更为明确，因而增强了可读性。例如： typedef int a[10]; 表示a是整型数组类型，数组长度为10。然后就可用a说明变量，例如:语句a s1,s2；完全等效于语句 int s1[10],s2[10].同理， typedef void（*p）（void)表示p是一种指向void型的指针类型。
**2.功能不同**

typedef 用来定义类型的别名，起到使类型易于记忆的功能

**3.作用域不同**

define没有作用域

typedef有自己的作用域

```c
void fun(){
    #define A int 
    #typedef B float
}
void gun(){
    //这里可以使用A但是不能使用B
}
```

---

### 内存管理

#### 内存四区

**代码区**     .text（代码区）.rodata(常量区)

所有的可执行代码（程序代码指令、常量字符串等）以及函数

**全局静态区**  .data(已初始化全局/静态变量) .bss(未初始化)

存放所有 全局变量和静态变量

**堆区** .Heap

动态内存分配

**栈区** .Stack

局部变量、函数形参等

#### 内存泄漏

栈区：局部变量过大或者多层函数嵌套

堆区:malloc内存后未释放

#### 栈溢出

栈大小只有几MB，当程序试图使用的栈空间超过其最大容量时，就会触发栈溢出，导致程序崩溃（如段错误或系统强制终止）

无限递归、过大的局部变量、过深的函数嵌套

栈和堆地址连续，入栈元素过多会影响到堆，申请内存过大会也影响到栈



#### new/delete与malloc/free的区别是什么

     对于类的对象而言，malloc/free无法满足**动态对象**的要求，对象在创建时要自动执行**构造函数**，在对象消亡之前要自动执行**析构函数**，而malloc/free 不在编译器控制权限之内，**无法执行**构造函数和析构函数。

    当然对于没有**资源要清理**的类，不调用析构函数也没有太大的问题，即使用free或delete没有区别。但万一有一些类的成员是**指针**，而这个指针又在**堆上开辟了空间**，这时不调用析构函数去释放这个指针指向的这段空间，就会造成**内存泄漏**。**delete**会调用析构函数，释放**指针成员变量**的空间，再**销毁对象本身的空间**；而**free**只释放了**对象本身的空间**，而**指针**成员所指向的空间**没有被释放**

- new能自动计算需要分配的内存空间，malloc需要手动计算字节数

- new/delete带具体类型指针，malloc/free返回**void**指针

- new/free将调用构造/析构函数，malloc/free不能

- new/free**不需要**库文件支持，malloc/free需要<stdlib.h>支持

注：delete和free被调用后，内存**不会立即**收回，指针也不会**指向空**，delete或free仅仅是**告诉操作系统**，这一块内存**被释放**啦，还可以做其他用途。由于没有对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现**野指针**的情况，因此，释放完内存后需要将指针向量**置为空**。



#### 局部变量未定义时为什么每次初始化的结果是不确定的？是个真随机数还是个伪随机数？

**局部变量未初始化**

局部变量存储在栈中，是动态存储方式，如果声明了一个变量，系统给这个变量分配了一块内存，这块内存可能存有之前使用过的值，这个值可能是任意值，如果新声明的这个变量没有被初始化，就相当于系统把这块内存中之前存在的值赋给了新声明的变量，这个值可能是任意值，因此得到的就是一个随机值，这种结果无法预测，可能导致灾难性的后果

**全局变量未初始化**

全部变量采取的是静态存储方式，在没有初始化之前，被放在BSS段中，操作系统在调用一个程序之前，会执行一段代码，这段代码会将BSS段中的空间全部清零，所以全局变量如果未初始化，其值就是0。

 **嵌套调用时**：局部变量如未定义为静态变量的话会出现**悬空指针**



### 字节对齐

**结构体字节对齐：**[结构体字节对齐](https://c.biancheng.net/view/243.html)

    以结构体成员中占**内存最多**的数据类型所占的字节数为标准,所有的成员在分配内存时都要与这个长度对齐。所有成员在分配内存时都是紧接在前一个变量后面**依次填充**的,如果不足以填充**另起一行**分配，**各类型成员的前后位置会对字节数产生影响**

注：char a[10] 的本质是 10 个 char 变量

**union判断大小端**

```c
   // 定义一个 union，包含 int 和 char[4]
    union {
        int i;        // 整数成员，通常占 4 字节
        char c[4];    // 字符数组成员，用于访问整数的每个字节
    } endianTest;

    // 设置整数值为 0x01020304（十六进制）
    endianTest.i = 0x01020304;

    // 检查字符数组的第一个字节（c[0]）
    endianTest.c[0] == 0x01)    "系统是大端（Big-endian）\n");
    endianTest.c[0] == 0x04)    "系统是小端（Little-endian）\n");
```

 

### 其他问题

#### 编译过程

**1.预处理阶段**   hello.c -> hello.i

处理所有以`#`开头的指令

- 头文件展开：将`#include <stdio.h>`替换为整个stdio.h文件的内容

- 宏替换：处理`#define`定义的宏

- 条件编译：处理`#ifdef`、`#ifndef`等条件编译指令

- 删除注释

**2.编译阶段**     hello.i ->hello.s

将预处理后的C代码转换为**汇编语言**

**3.汇编阶段**   hello.s -> hello.o

汇编器将人类可读的汇编代码转换为机器码

- 汇编指令 -> 机器指令

- 生成目标文件（.o文件）

- 创建符号表，记录函数和变量地址信息

此时的.o文件包含二进制机器码，但是还不能直接执行，缺少一些关键信息

**4.链接阶段**     hello.o -> hello

将多个目标文件和库文件组合成最终的可执行文件

#### 大小端

大端：高地址存低字节，低地址存高字节  
小端：低地址存低字节，高地址存高字节

---



# 硬件

### 启动流程



## 中断

### 中断ISR

中断ISR不同于其他用户软件程序，属于一类特殊的函数，原因入下：

1. 中断ISR必须是**void型的无参数**传递函数--无形参无返回值；

2. 中断ISR由**硬件外设触发**，而非其他函数调用，其运行时机具有**随机不确定性和硬件实时性**

3. 中断ISR运行**时间必须尽量短**，以**保证**外设中断的**实时性**；

在中断ISR中需要完成以下工作：

1. 将引起该中断请求的**外设中断标志清除**，**保证外设不**因该中断ISR运行而**丢失下一次中断**，而CPU在中断退出后可以处理其他任务；

2. 处理外设中断事件，典型如定时计数，通信外设RX数据接收或者TX数据buffer填充等；

    为了保证中断的实时性，中断ISR程序要尽量短，不能条件等待语句甚至将死循环语句放在中断ISR内。建议用户一般只把关键处理放在中断ISR中，其他相关的一般性工作放在主程序中执行。典型例子如CAN的数据接收放在CAN RX 中断ISR中，而通过全局变量通知主程序执行相关的诊断协议(如UDS)。

### 中断嵌套

是指在外设中断具有不同的优先级，在CPU响应**低优先级**中断的时候(也就是运行中断ISR时)，**打开CPU全局中断**，如果此时有更**高优先级**的中断到来，CPU能够**停下**当前的中断处理区响应优先级高的中断，从而**保证高优先级任务外设响应实时性**的情况

### 中断向量表

中断向量表是一个存储中断服务程序入口地址的数组或表格，每个中断源对应一个表项。

作用：

- 提供中断源与对应服务程序之间的映射关系
- 使CPU能够快速找到并跳转到正确的中断服务程序
- 支持多种中断源的统一管理

Cortex-M 的中断向量表中列举出了所有的中断，每一个中断对应一个中断服务函数；而 Cortex-A 的中断向量表则是将中断分为了 7类

### 保护、恢复现场
