# C语言

---

### 关键字

#### volatile 易变的

主要是防止编译器对变量进行优化

```c
int a,b;    //为a b申请内存
a = 1;      // 1-> CUP  CPU -> 内存(&a)
b = a;      //内存(&a)->CPU CPU->内存(&b)
c = b;      //优化则不需要重新内存a到CPU，直接将CPU中的a传递给c
            //加上修饰后则重新去内存取值
```

哪些情况使用volatile

- 并行设备的硬件寄存器

- 中断服务程序中修改的供其他程序检测的变量

- 多线程中被几个任务共享的变量

#### unsigned 无符号数据类型

```c
void foo(void){
    unsigned int a = 6;
    int b = -20;
    (a+b>6)? puts(">6"):puts("<=6")
}
```

这无符号整型问题的答案是输出是 “>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都**自动转换为无符号类型**。因此-20变成了一个**非常大的正整数**，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。

#### Const 常量修饰符

阻止一个变量被修改

#### typedef 和 define 的区别

**1.原理不同**

 #**define是预处理指令**，在**预处理**时进行简单而机械的**字符串替换**，不做正确性检査。 例如， # define Pl 3.1415926 ，当程序执行 area=PI * r 语句时，PI会被替换为3.1415926。于是该 语句被替换为 area=3.1415926*r 。如果把# define语句中的数字9写成了g，预处理也照样代入，而不去检查其是否合理、合法。 **typedef是关键字**，它在**编译**时处理，所以 typedef具有**类型检查**的功能。它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符 typedef。例如，typedef int INTEGER ，这以后就可用 INTEGER来代替int作整型变量的类型说明了，例如：INTEGER a,b; 用 typedef定义数组、指针、结构等类型将带来很大的方便，不仅使程序书写简单而且使意义更为明确，因而增强了可读性。例如： typedef int a[10]; 表示a是整型数组类型，数组长度为10。然后就可用a说明变量，例如:语句a s1,s2；完全等效于语句 int s1[10],s2[10].同理， typedef void（*p）（void)表示p是一种指向void型的指针类型。
**2.功能不同**

typedef 用来定义类型的别名，起到使类型易于记忆的功能

**3.作用域不同**

define没有作用域

typedef有自己的作用域

```c
void fun(){
    #define A int 
    #typedef B float
}
void gun(){
    //这里可以使用A但是不能使用B
}
```

---

### 内存管理

#### 内存四区

**代码区**     .text（代码区）.rodata(常量区)

所有的可执行代码（程序代码指令、常量字符串等）以及函数

**全局静态区**  .data(已初始化全局/静态变量) .bss(未初始化)

存放所有 全局变量和静态变量

**堆区** .Heap

动态内存分配

**栈区** .Stack

局部变量、函数形参等

#### 内存泄漏

栈区：局部变量过大或者多层函数嵌套

堆区:malloc内存后未释放



#### 栈溢出

栈大小只有几MB，当程序试图使用的栈空间超过其最大容量时，就会触发栈溢出，导致程序崩溃（如段错误或系统强制终止）

无限递归、过大的局部变量、过深的函数嵌套

栈和堆地址连续，入栈元素过多会影响到堆，申请内存过大会也影响到栈

#### new/delete与malloc/free的区别是什么

     对于类的对象而言，malloc/free无法满足**动态对象**的要求，对象在创建时要自动执行**构造函数**，在对象消亡之前要自动执行**析构函数**，而malloc/free 不在编译器控制权限之内，**无法执行**构造函数和析构函数。

    当然对于没有**资源要清理**的类，不调用析构函数也没有太大的问题，即使用free或delete没有区别。但万一有一些类的成员是**指针**，而这个指针又在**堆上开辟了空间**，这时不调用析构函数去释放这个指针指向的这段空间，就会造成**内存泄漏**。**delete**会调用析构函数，释放**指针成员变量**的空间，再**销毁对象本身的空间**；而**free**只释放了**对象本身的空间**，而**指针**成员所指向的空间**没有被释放**

- new能自动计算需要分配的内存空间，malloc需要手动计算字节数

- new/delete带具体类型指针，malloc/free返回**void**指针

- new/free将调用构造/析构函数，malloc/free不能

- new/free**不需要**库文件支持，malloc/free需要<stdlib.h>支持

注：delete和free被调用后，内存**不会立即**收回，指针也不会**指向空**，delete或free仅仅是**告诉操作系统**，这一块内存**被释放**啦，还可以做其他用途。由于没有对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现**野指针**的情况，因此，释放完内存后需要将指针向量**置为空**。

#### 局部变量未定义时为什么每次初始化的结果是不确定的？是个真随机数还是个伪随机数？

**局部变量未初始化**

局部变量存储在栈中，是动态存储方式，如果声明了一个变量，系统给这个变量分配了一块内存，这块内存可能存有之前使用过的值，这个值可能是任意值，如果新声明的这个变量没有被初始化，就相当于系统把这块内存中之前存在的值赋给了新声明的变量，这个值可能是任意值，因此得到的就是一个随机值，这种结果无法预测，可能导致灾难性的后果

**全局变量未初始化**

全部变量采取的是静态存储方式，在没有初始化之前，被放在BSS段中，操作系统在调用一个程序之前，会执行一段代码，这段代码会将BSS段中的空间全部清零，所以全局变量如果未初始化，其值就是0。

 **嵌套调用时**：局部变量如未定义为静态变量的话会出现**悬空指针**

### 其他问题



#### 编译过程

**1.预处理阶段**   hello.c -> hello.i

处理所有以`#`开头的指令

- 头文件展开：将`#include <stdio.h>`替换为整个stdio.h文件的内容

- 宏替换：处理`#define`定义的宏

- 条件编译：处理`#ifdef`、`#ifndef`等条件编译指令

- 删除注释

**2.编译阶段**     hello.i ->hello.s

将预处理后的C代码转换为**汇编语言**

**3.汇编阶段**   hello.s -> hello.o

汇编器将人类可读的汇编代码转换为机器码

- 汇编指令 -> 机器指令

- 生成目标文件（.o文件）

- 创建符号表，记录函数和变量地址信息

此时的.o文件包含二进制机器码，但是还不能直接执行，缺少一些关键信息

**4.链接阶段**     hello.o -> hello

将多个目标文件和库文件组合成最终的可执行文件



#### 大小端

大端：高地址存低字节，低地址存高字节  
小端：低地址存低字节，高地址存高字节
